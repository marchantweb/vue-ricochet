<template>
  <canvas :width="containerSize.width" :height="containerSize.height" class="ricochet-canvas canvas__anchors" ref="ricochet-canvas-anchor"/>
  <div class="ricochet-container" ref="ricochet-container">
    <template v-for="(vnode, index) in $slots.default()" :key="index">
      <!--suppress JSValidateTypes -->
      <component :is="vnode" :ref="'element--' + index" :style="elementStyles[index]"/>
    </template>
  </div>
</template>

<script>
import _ from 'lodash';
import layoutChain from "../layouts/chain";
import layoutCircle from "../layouts/circle";
import layoutArc from "../layouts/arc";
import layoutLine from "../layouts/line";

export default {
  props: {
    type: {
      default: 'circle'
    },
  },
  data() {
    return {
      elements: [],
      layout: null,
      changeObserver: null,
      resizeObserver: null,
      resizeElementObserver: null,
      repositionElements: _.throttle(this._handleReposition, (1000 / this.$ricochet._config.fps), {'trailing': false}),
      containerSize: {
        width: 0,
        height: 0
      }
    }
  },
  methods: {

    /**
     * Setup observers to watch for changes to the container and its children.
     */
    setupObservers() {
      this.changeObserver = new MutationObserver(function (mutations) {
        this.repositionElements();
      }.bind(this));
      this.resizeObserver = new ResizeObserver(function (entries) {
        this.updateContainerSize();
        this.repositionElements();
      }.bind(this));
      this.resizeElementObserver = new ResizeObserver(function (entries) {
        this.repositionElements();
      }.bind(this));
      // Observe the container for changes/resize
      this.changeObserver.observe(this.$refs['ricochet-container'], {attributes: false, childList: true, characterData: false, subtree: false});
      this.resizeObserver.observe(this.$refs['ricochet-container']);
      // Observe each element for resize
      for (const element of this.elements) {
        this.resizeElementObserver.observe(element);
      }
    },

    /**
     * Position elements in the ricochet container (throttled to the config FPS).
     */
    _handleReposition() {
      if (!this.$refs['ricochet-container']) {
        return;
      }
      this.elements = [].slice.call(this.$refs['ricochet-container'].children);
      if (this.type === 'circle') {
        this.layout = layoutCircle(this.elements, {
          center: {
            x: this.containerSize.width / 2,
            y: this.containerSize.height / 2
          },
        });
      } else if (this.type === 'arc') {
        this.layout = layoutArc(this.elements, {
          center: {
            x: this.containerSize.width / 2,
            y: this.containerSize.height / 2
          },
          startAngle: 0,
          endAngle: 180,
        });
      } else if (this.type === 'line') {
        this.layout = layoutLine(this.elements, {
          start: {
            x: 50,
            y: 50
          },
          end: {
            x: (this.containerSize.width) - 50,
            y: (this.containerSize.height) - 50
          },
        });
      } else {
        this.layout = layoutChain(this.elements);
      }
    },

    /**
     * Handle the resize event.
     */
    updateContainerSize() {
      if (this.$refs['ricochet-container']) {
        this.containerSize.width = this.$refs['ricochet-container'].offsetWidth;
        this.containerSize.height = this.$refs['ricochet-container'].offsetHeight;
      }
    }

  },
  computed: {

    /**
     * How many elements are in our container?
     * @returns {number}
     */
    elementCount() {
      return this.elements.length;
    },

    /**
     * Returns an array of styles for each element in the container.
     * @returns {*[]}
     */
    elementStyles() {
      let styles = [];
      if (this.layout && this.layout.length && this.elements.length === this.layout.length) {
        for (let i = 0; i < this.elements.length; i++) {
          styles.push({
            position: 'absolute',
            top: 0,
            left: 0,
            'transform': "translate(" + this.layout[i].x + "px, " + this.layout[i].y + "px)",
          });
        }
      }
      return styles;
    },

  },
  mounted() {
    this.updateContainerSize();
    this.repositionElements();
    this.setupObservers();
  },
  beforeDestroy: function () {

    /**
     * Clean-up the change and resize observers
     */
    this.changeObserver.disconnect();
    this.resizeElementObserver.disconnect();
  }
}
</script>

<style scoped>

.ricochet-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.ricochet-canvas {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
}

</style>
